{"version":3,"file":"static/js/5448.1eef1172.chunk.js","mappings":"gMAoBMA,EAAa,SAACC,EAAGC,EAAIC,GAAE,SAAQ,EAAM,EAAMA,EAAK,EAAMD,GAAMD,GAAK,EAAME,EAAK,EAAMD,IAAOD,EAAI,EAAMC,GACrGD,CAAC,EAoBL,SAASG,EAAYC,EAAKC,EAAKC,EAAKC,GAEhC,GAAIH,IAAQC,GAAOC,IAAQC,EACvB,OAAOC,EAAAA,EACX,IAAMC,EAAW,SAACC,GAAE,OArBxB,SAAyBC,EAAGC,EAAYC,EAAYT,EAAKE,GACrD,IAAIQ,EACAC,EACAC,EAAI,EACR,IAEIF,EAAWf,EADXgB,EAAWH,GAAcC,EAAaD,GAAc,EACpBR,EAAKE,GAAOK,GAC7B,EACXE,EAAaE,EAGbH,EAAaG,QAEZE,KAAKC,IAAIJ,GAfO,QAgBnBE,EAfuB,IAgB7B,OAAOD,CACX,CAK6BI,CAAgBT,EAAI,EAAG,EAAGN,EAAKE,EAAI,EAE5D,OAAO,SAACN,GAAC,OAAW,IAANA,GAAiB,IAANA,EAAUA,EAAID,EAAWU,EAAST,GAAIK,EAAKE,EAAI,CAC5E,CC9CA,IAAMa,EAASjB,EAAY,IAAM,EAAG,EAAG,GACjCkB,EAAUlB,EAAY,EAAG,EAAG,IAAM,GAClCmB,EAAYnB,EAAY,IAAM,EAAG,IAAM,G,sDCAvCoB,EAAUpB,EAAY,IAAM,KAAM,IAAM,KACxCqB,GAASC,EAAAA,EAAAA,GAAcF,GACvBG,GAAYC,EAAAA,EAAAA,GAAaH,GCEzBI,EAAe,CACjBC,OAAQrB,EAAAA,EACRY,OAAAA,EACAE,UAAAA,EACAD,QAAAA,EACAS,OAAAA,EAAAA,GACAC,UAAAA,EAAAA,GACAC,QAAAA,EAAAA,GACAR,OAAAA,EACAE,UAAAA,EACAH,QAAAA,EACAU,WCjBe,SAACC,GAAC,OAAMA,GAAK,GAAK,EAAI,GAAMV,EAAOU,GAAK,IAAO,EAAIjB,KAAKkB,IAAI,GAAI,IAAMD,EAAI,IAAI,GDmB3FE,EAA6B,SAACC,GAChC,GAAIC,MAAMC,QAAQF,GAAa,EAE3BG,EAAAA,EAAAA,GAAgC,IAAtBH,EAAWI,OAAc,2DACnC,IAAAC,GAAAC,EAAAA,EAAAA,GAAyBN,EAAU,GACnC,OAAOlC,EADEuC,EAAA,GAAIA,EAAA,GAAIA,EAAA,GAAIA,EAAA,GAEzB,CACK,MAA0B,kBAAfL,IAEZG,EAAAA,EAAAA,QAAuCI,IAA7BhB,EAAaS,GAA2B,wBAAFQ,OAA0BR,EAAU,MAC7ET,EAAaS,IAEjBA,CACX,E,qBExBA,SAASS,EAASC,GAA4E,IAHvEC,EAAQC,EAG+DC,EAAAH,EAAzEI,SAAAA,OAAQ,IAAAD,EAAG,IAAGA,EAAaE,EAAcL,EAAzBD,UAA2BO,EAAKN,EAALM,MAAKC,EAAAP,EAAEQ,KAAAA,OAAI,IAAAD,EAAG,YAAWA,EAK/EE,ECfY,SAACD,GACnB,OAAOjB,MAAMC,QAAQgB,IAA4B,kBAAZA,EAAK,EAC9C,CDa4BE,CAAcF,GAChCA,EAAKG,IAAItB,GACTA,EAA2BmB,GAK3BI,EAAQ,CACVC,MAAM,EACNC,MAAOT,EAAe,IAKpBU,EE7BV,SAA8BC,EAAQZ,GAClC,OAAOY,EAAOL,KAAI,SAACM,GAAC,OAAKA,EAAIb,CAAQ,GACzC,CF2B0Bc,CAGtBZ,GAASA,EAAMZ,SAAWW,EAAeX,OACnCY,GACAa,EAAAA,EAAAA,GAAcd,GAAiBD,GAC/BgB,GAAoBC,EAAAA,EAAAA,GAAYN,EAAeV,EAAgB,CACjEG,KAAMjB,MAAMC,QAAQiB,GACdA,GA9BSR,EA+BKI,EA/BGH,EA+BaO,EA9BjCR,EAAOU,KAAI,kBAAMT,GAAU3B,CAAS,IAAE+C,OAAO,EAAGrB,EAAOP,OAAS,MAgCvE,MAAO,CACH6B,mBAAoBnB,EACpBoB,KAAM,SAACvE,GAGH,OAFA2D,EAAME,MAAQM,EAAkBnE,GAChC2D,EAAMC,KAAO5D,GAAKmD,EACXQ,CACX,EAER,C,0BG7CA,SAASa,EAAsBC,EAAczE,EAAG0E,GAC5C,IAAMC,EAAQ1D,KAAK2D,IAAI5E,EAFI,EAEwB,GACnD,OAAO6E,EAAAA,EAAAA,GAAkBH,EAAUD,EAAaE,GAAQ3E,EAAI2E,EAChE,C,cCFMG,EAAU,KAKhB,SAASC,EAAUhC,GAA6D,IACxEiC,EACAC,EAFwE/B,EAAAH,EAA1DI,SAAAA,OAAQ,IAAAD,EAAG,IAAGA,EAAAgC,EAAAnC,EAAEoC,OAAAA,OAAM,IAAAD,EAAG,IAAIA,EAAAE,EAAArC,EAAEsC,SAAAA,OAAQ,IAAAD,EAAG,EAACA,EAAAE,EAAAvC,EAAEwC,KAAAA,OAAI,IAAAD,EAAG,EAACA,GAGvEE,EAAAA,EAAAA,GAAQrC,IAAYsC,EAAAA,EAAAA,GANJ,IAMwC,8CACxD,IAAIC,EAAe,EAAIP,EAIvBO,GAAeC,EAAAA,EAAAA,GAVA,IACA,EAS8BD,GAC7CvC,GAAWwC,EAAAA,EAAAA,GAbK,IACA,IAY2BC,EAAAA,EAAAA,GAAsBzC,IAC7DuC,EAAe,GAIfV,EAAW,SAACa,GACR,IAAMC,EAAmBD,EAAeH,EAClCK,EAAQD,EAAmB3C,EAC3B6C,EAAIF,EAAmBT,EACvBY,EAAIC,EAAgBL,EAAcH,GAClCS,EAAIlF,KAAKmF,KAAKL,GACpB,OAAOjB,EAAWkB,EAAIC,EAAKE,CAC/B,EACAlB,EAAa,SAACY,GACV,IACME,EADmBF,EAAeH,EACPvC,EAC3BkD,EAAIN,EAAQV,EAAWA,EACvBiB,EAAIrF,KAAKkB,IAAIuD,EAAc,GAAKzE,KAAKkB,IAAI0D,EAAc,GAAK1C,EAC5DoD,EAAItF,KAAKmF,KAAKL,GACdS,EAAIN,EAAgBjF,KAAKkB,IAAI0D,EAAc,GAAIH,GAErD,QADgBV,EAASa,GAAgBf,EAAU,GAAK,EAAI,KACzCuB,EAAIC,GAAKC,GAAMC,CACtC,IAMAxB,EAAW,SAACa,GAGR,OAFU5E,KAAKmF,KAAKP,EAAe1C,KACxB0C,EAAeR,GAAYlC,EAAW,GAC1C,IACX,EACA8B,EAAa,SAACY,GAGV,OAFU5E,KAAKmF,KAAKP,EAAe1C,IACIA,EAAWA,GAAvCkC,EAAWQ,GAE1B,GAEJ,IACMA,EAmBV,SAAyBb,EAAUC,EAAYwB,GAE3C,IADA,IAAIC,EAASD,EACJzF,EAAI,EAAGA,EAHG,GAGiBA,IAChC0F,GAAkB1B,EAAS0B,GAAUzB,EAAWyB,GAEpD,OAAOA,CACX,CAzByBC,CAAgB3B,EAAUC,EAD1B,EAAI9B,GAGzB,GADAA,GAAWsC,EAAAA,EAAAA,GAAsBtC,GAC7ByD,MAAMf,GACN,MAAO,CACHgB,UAAW,IACXC,QAAS,GACT3D,SAAAA,GAIJ,IAAM0D,EAAY5F,KAAKkB,IAAI0D,EAAc,GAAKN,EAC9C,MAAO,CACHsB,UAAAA,EACAC,QAAwB,EAAfpB,EAAmBzE,KAAK8F,KAAKxB,EAAOsB,GAC7C1D,SAAAA,EAGZ,CASA,SAAS+C,EAAgBL,EAAcH,GACnC,OAAOG,EAAe5E,KAAK8F,KAAK,EAAIrB,EAAeA,EACvD,C,4CClFMsB,EAAe,CAAC,WAAY,UAC5BC,EAAc,CAAC,YAAa,UAAW,QAC7C,SAASC,EAAaC,EAASC,GAC3B,OAAOA,EAAKC,MAAK,SAACC,GAAG,YAAsB1E,IAAjBuE,EAAQG,EAAkB,GACxD,CAwBA,SAASC,EAAMxE,GAAkD,IAuBzDyE,EAvBU1E,EAASC,EAATD,UAAW2E,EAAS1E,EAAT0E,UAAWC,EAAS3E,EAAT2E,UAAcP,GAAOQ,EAAAA,EAAAA,GAAA5E,EAAA6E,GACnDC,EAAS/E,EAAU,GACnBgF,EAAShF,EAAUA,EAAUL,OAAS,GAKtCkB,EAAQ,CAAEC,MAAM,EAAOC,MAAOgE,GACpCE,EA/BJ,SAA0BZ,GACtB,IAAIa,GAAaC,EAAAA,EAAAA,GAAA,CACb5C,SAAU,EACVwB,UAAW,IACXC,QAAS,GACTvB,KAAM,EACN2C,wBAAwB,GACrBf,GAGP,IAAKD,EAAaC,EAASF,IACvBC,EAAaC,EAASH,GAAe,CACrC,IAAMmB,EAAUpD,EAAWoC,IAC3Ba,GAAaC,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAA,GACND,GACAG,GAAO,IACV9C,SAAU,EACVE,KAAM,KAEI2C,wBAAyB,CAC3C,CACA,OAAOF,CACX,CASsFI,CAAiBjB,GAA3FN,EAASkB,EAATlB,UAAWC,EAAOiB,EAAPjB,QAASvB,EAAIwC,EAAJxC,KAAMF,EAAQ0C,EAAR1C,SAAUlC,EAAQ4E,EAAR5E,SAAU+E,EAAsBH,EAAtBG,uBAChDG,EAAkBhD,IAAYO,EAAAA,EAAAA,GAAsBP,GAAY,EAChEK,EAAeoB,GAAW,EAAI7F,KAAK8F,KAAKF,EAAYtB,IACpD+C,EAAeR,EAASD,EACxBU,GAAsB3C,EAAAA,EAAAA,GAAsB3E,KAAK8F,KAAKF,EAAYtB,IAQlEiD,EAAkBvH,KAAKC,IAAIoH,GAAgB,EAIjD,GAHAZ,IAAcA,EAAYc,EAAkB,IAAO,GACnDf,IAAcA,EAAYe,EAAkB,KAAQ,IAEhD9C,EAAe,EAAG,CAClB,IAAM+C,EAAcvC,EAAgBqC,EAAqB7C,GAEzD8B,EAAgB,SAACxH,GACb,IAAMgF,EAAW/D,KAAKmF,KAAKV,EAAe6C,EAAsBvI,GAChE,OAAQ8H,EACJ9C,IACOqD,EACC3C,EAAe6C,EAAsBD,GACrCG,EACAxH,KAAKyH,IAAID,EAAczI,GACvBsI,EAAerH,KAAK0H,IAAIF,EAAczI,GACtD,CACJ,MACK,GAAqB,IAAjB0F,EAEL8B,EAAgB,SAACxH,GAAC,OAAK8H,EACnB7G,KAAKmF,KAAKmC,EAAsBvI,IAC3BsI,GACID,EAAkBE,EAAsBD,GAAgBtI,EAAE,MAEtE,CAED,IAAM4I,EAAoBL,EAAsBtH,KAAK8F,KAAKrB,EAAeA,EAAe,GACxF8B,EAAgB,SAACxH,GACb,IAAMgF,EAAW/D,KAAKmF,KAAKV,EAAe6C,EAAsBvI,GAE1D6I,EAAW5H,KAAK6H,IAAIF,EAAoB5I,EAAG,KACjD,OAAQ8H,EACH9C,IACKqD,EACE3C,EAAe6C,EAAsBD,GACrCrH,KAAK8H,KAAKF,GACVD,EACIN,EACArH,KAAK+H,KAAKH,IAClBD,CACZ,CACJ,CACA,MAAO,CACHtE,mBAAoB4D,GAAyB/E,GAAmB,KAChEoB,KAAM,SAACvE,GACH,IAAM0E,EAAU8C,EAAcxH,GAC9B,GAAKkI,EAqBDvE,EAAMC,KAAO5D,GAAKmD,MArBO,CACzB,IAAI8F,EAAkBZ,EACZ,IAANrI,IAOIiJ,EADAvD,EAAe,EACGlB,EAAsBgD,EAAexH,EAAG0E,GAGxC,GAG1B,IAAMwE,EAA2BjI,KAAKC,IAAI+H,IAAoBvB,EACxDyB,EAA+BlI,KAAKC,IAAI4G,EAASpD,IAAY+C,EACnE9D,EAAMC,KACFsF,GAA4BC,CACpC,CAKA,OADAxF,EAAME,MAAQF,EAAMC,KAAOkE,EAASpD,EAC7Bf,CACX,EAER,CC3HA,SAASyF,EAAOrG,GAAiK,IAA9JD,EAASC,EAATD,UAASsC,EAAArC,EAAEsC,SAAAA,OAAQ,IAAAD,EAAG,EAAGA,EAAAiE,EAAAtG,EAAEuG,MAAAA,OAAK,IAAAD,EAAG,GAAGA,EAAAE,EAAAxG,EAAEyG,aAAAA,OAAY,IAAAD,EAAG,IAAGA,EAAAE,EAAA1G,EAAE2G,cAAAA,OAAa,IAAAD,EAAG,GAAEA,EAAAE,EAAA5G,EAAE6G,gBAAAA,OAAe,IAAAD,EAAG,IAAGA,EAAEE,EAAY9G,EAAZ8G,aAAcf,EAAG/F,EAAH+F,IAAKlE,EAAG7B,EAAH6B,IAAGkF,EAAA/G,EAAE0E,UAAAA,OAAS,IAAAqC,EAAG,GAAGA,EAAEpC,EAAS3E,EAAT2E,UACzJG,EAAS/E,EAAU,GACnBa,EAAQ,CACVC,MAAM,EACNC,MAAOgE,GAGLkC,EAAkB,SAACC,GACrB,YAAYpH,IAARkG,EACOlE,OACChC,IAARgC,GAEG3D,KAAKC,IAAI4H,EAAMkB,GAAK/I,KAAKC,IAAI0D,EAAMoF,GAD/BlB,EAC0ClE,CACzD,EACIqF,EAAYX,EAAQjE,EAClB6E,EAAQrC,EAASoC,EACjBnC,OAA0BlF,IAAjBiH,EAA6BK,EAAQL,EAAaK,GAK7DpC,IAAWoC,IACXD,EAAYnC,EAASD,GACzB,IAcIsC,EACAC,EAfEC,EAAY,SAACrK,GAAC,OAAMiK,EAAYhJ,KAAKmF,KAAKpG,EAAIwJ,EAAa,EAC3Dc,EAAa,SAACtK,GAAC,OAAK8H,EAASuC,EAAUrK,EAAE,EACzCuK,EAAgB,SAACvK,GACnB,IAAM+F,EAAQsE,EAAUrK,GAClBwK,EAASF,EAAWtK,GAC1B2D,EAAMC,KAAO3C,KAAKC,IAAI6E,IAAU0B,EAChC9D,EAAME,MAAQF,EAAMC,KAAOkE,EAAS0C,CACxC,EASMC,EAAqB,SAACzK,GAjCN,IAACgK,KAkCArG,EAAME,WAlCSjB,IAARkG,GAAqBkB,EAAIlB,QAAiBlG,IAARgC,GAAqBoF,EAAIpF,KAoCrFuF,EAAsBnK,EACtBoK,EAAW7C,EAAO,CACdzE,UAAW,CAACa,EAAME,MAAOkG,EAAgBpG,EAAME,QAC/CwB,SAAUb,EAAsB8F,EAAYtK,EAAG2D,EAAME,OACrDiD,QAAS4C,EACT7C,UAAW+C,EACXnC,UAAAA,EACAC,UAAAA,IAER,EAEA,OADA+C,EAAmB,GACZ,CACHnG,mBAAoB,KACpBC,KAAM,SAACvE,GAOH,IAAI0K,GAAkB,EAUtB,OATKN,QAAoCxH,IAAxBuH,IACbO,GAAkB,EAClBH,EAAcvK,GACdyK,EAAmBzK,SAMK4C,IAAxBuH,GAAqCnK,EAAImK,EAClCC,EAAS7F,KAAKvE,EAAImK,KAGxBO,GAAmBH,EAAcvK,GAC3B2D,EAEf,EAER,C,0BCjFMgH,EAAkB,SAACC,GACrB,IAAMC,EAAgB,SAAH9H,GAAA,IAAM+H,EAAS/H,EAAT+H,UAAS,OAAOF,EAAOE,EAAU,EAC1D,MAAO,CACHC,MAAO,kBAAMC,EAAAA,GAAAA,OAAaH,GAAe,EAAK,EAC9CI,KAAM,kBAAMC,EAAAA,EAAAA,IAAYL,EAAc,EAKtCM,IAAK,kBAAMC,EAAAA,EAAAA,aAAyBA,EAAAA,EAAAA,UAAsBC,YAAYF,KAAK,EAEnF,ECTA,SAASG,EAAsBC,GAI3B,IAHA,IAAIpI,EAAW,EAEXQ,EAAQ4H,EAAUhH,KAAKpB,IACnBQ,EAAMC,MAAQT,EALG,KAMrBA,GAHa,GAIbQ,EAAQ4H,EAAUhH,KAAKpB,GAE3B,OAAOA,GATkB,IASiBqI,IAAWrI,CACzD,C,qICLMsI,EAAQ,CACVC,MAAOtC,EACPA,QAAAA,EACAuC,MAAO7I,EACPA,UAAWA,EACXyE,OAAAA,GASJ,SAASqE,EAAY7I,GAA2M,IAGxN8I,EACAC,EAcAC,EAlBwNC,EAAAjJ,EAAxMkJ,SAAAA,OAAQ,IAAAD,GAAOA,EAAAE,EAAAnJ,EAAEoJ,MAAAA,OAAK,IAAAD,EAAG,EAACA,EAAAE,EAAArJ,EAAEsJ,OAAAA,OAAM,IAAAD,EAAGzB,EAAeyB,EAAaE,EAAWvJ,EAAtBD,UAASyJ,EAAAxJ,EAAeyJ,KAAAA,OAAI,IAAAD,EAAG,YAAWA,EAAAE,EAAA1J,EAAE2J,OAAAA,OAAM,IAAAD,EAAG,EAACA,EAAAE,EAAA5J,EAAE6J,YAAAA,OAAW,IAAAD,EAAG,EAACA,EAAAE,EAAA9J,EAAE+J,WAAAA,OAAU,IAAAD,EAAG,OAAMA,EAAEE,EAAMhK,EAANgK,OAAQC,EAAMjK,EAANiK,OAAQC,EAAUlK,EAAVkK,WAAYC,EAAQnK,EAARmK,SAAa/F,GAAOQ,EAAAA,EAAAA,GAAA5E,EAAA6E,GACpNuF,EAAQ,EACRC,GAAa,EAQXC,EAAwB,WAC1BxB,GAA0BA,IAC1BC,EAAyB,IAAIwB,SAAQ,SAACC,GAClC1B,EAAyB0B,CAC7B,GACJ,EAEAF,IAEA,IAMIG,EANEC,EAAmBhC,EAAMe,IAAS1J,EAOpC2K,IAAqB3K,GACK,kBAAnBwJ,EAAY,KACnBkB,GAAwBpJ,EAAAA,EAAAA,GAAY,CAAC,EAAG,KAAMkI,EAAa,CACvD3G,OAAO,IAEX2G,EAAc,CAAC,EAAG,MAEtB,IACIoB,EADEnC,EAAYkC,GAAgBxF,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAAId,GAAO,IAAErE,UAAWwJ,KAEzC,WAAfQ,IACAY,EAAoBD,GAAgBxF,EAAAA,EAAAA,IAAAA,EAAAA,EAAAA,GAAC,CAAC,EAC/Bd,GAAO,IACVrE,WAAW6K,EAAAA,EAAAA,GAAIrB,GAAasB,UAC5BvI,WAAY8B,EAAQ9B,UAAY,OAGxC,IAAIwI,EAAY,OACZC,EAAW,KACXC,EAAY,KACZC,EAAa,KASoB,OAAjCzC,EAAUjH,oBAA+BoI,IACzCnB,EAAUjH,mBAAqBgH,EAAsBC,IAEzD,IAAQjH,EAAuBiH,EAAvBjH,mBACJ2J,EAAmBzC,IACnB0C,EAAgB1C,IACO,OAAvBlH,IAEA4J,GADAD,EAAmB3J,EAAqBsI,IACJF,EAAS,GAAKE,GAEtD,IAAIuB,EAAc,EACZC,EAAO,SAACtD,GACV,GAAkB,OAAdiD,EAAJ,CAQIZ,EAAQ,IACRY,EAAY9M,KAAK6H,IAAIiF,EAAWjD,IAQpC,IAAMuD,GANFF,EADa,OAAbL,EACcA,GAGChD,EAAYiD,GAAaZ,GAGLhB,EACjCmC,EAAiBD,EAAmB,EAC1CF,EAAclN,KAAK2D,IAAIyJ,EAAkB,GAKvB,aAAdR,GAAyC,OAAbC,IAC5BK,EAAcD,GAElB,IAAIK,EAAUJ,EACVK,EAAiBjD,EACrB,GAAImB,EAAQ,CAMR,IAAM+B,EAAWN,EAAcF,EAK3BS,EAAmBzN,KAAK0N,MAAMF,GAK9BG,EAAoBH,EAAW,GAK9BG,GAAqBH,GAAY,IAClCG,EAAoB,GAEF,IAAtBA,GAA2BF,IAC3BA,EAAmBzN,KAAK6H,IAAI4F,EAAkBhC,EAAS,GAIvD,IAAMmC,EAAiBC,QAAQJ,EAAmB,GAC9CG,IACmB,YAAf/B,GACA8B,EAAoB,EAAIA,EACpBhC,IACAgC,GAAqBhC,EAAcqB,IAGnB,WAAfnB,IACL0B,EAAiBd,IAGzB,IAAIxL,GAAIyD,EAAAA,EAAAA,GAAM,EAAG,EAAGiJ,GAChBT,EAAcD,IACdhM,EAAmB,YAAf4K,GAA4B+B,EAAiB,EAAI,GAEzDN,EAAUrM,EAAI+L,CAClB,CAMA,IAAMtK,EAAQ2K,EACR,CAAE1K,MAAM,EAAOC,MAAOyI,EAAY,IAClCkC,EAAejK,KAAKgK,GACtBf,IACA7J,EAAME,MAAQ2J,EAAsB7J,EAAME,QAE9C,IAAMD,EAASD,EAATC,KACD0K,GAAyC,OAAvBhK,IACnBV,EAAOuK,GAAeD,GAE1B,IAAMa,EAAmC,OAAbjB,IACT,aAAdD,GACkB,YAAdA,GAA2BjK,GAC3BuJ,EAAQ,GAAKgB,GAAe,GAOrC,OANIjB,GACAA,EAASvJ,EAAME,OAEfkL,GACAC,IAEGrL,CApGG,CAqGd,EACMsL,EAAsB,WACxBlD,GAAmBA,EAAgBd,OACnCc,OAAkBnJ,CACtB,EACMsM,EAAS,WACXrB,EAAY,OACZoB,IACA5B,IACAU,EAAYC,EAAa,IAC7B,EACMgB,EAAS,WACXnB,EAAY,WACZZ,GAAcA,IACdgC,IACA5B,GACJ,EACM8B,GAAO,WACT,IAAI/B,EAAJ,CAEKrB,IACDA,EAAkBM,EAAO+B,IAC7B,IAAMjD,EAAMY,EAAgBZ,MAC5B4B,GAAUA,IACO,OAAbe,EACAC,EAAY5C,EAAM2C,EAEZC,GAA2B,aAAdF,IACnBE,EAAY5C,GAEhB6C,EAAaD,EACbD,EAAW,KAKXD,EAAY,UACZ9B,EAAgBhB,OAlBN,CAmBd,EACIkB,GACAkD,KAEJ,IAAMC,GAAW,CACbC,KAAI,SAAC9B,EAAS+B,GACV,OAAOxD,EAAuBuD,KAAK9B,EAAS+B,EAChD,EACIC,WACA,OAAO3J,EAAAA,EAAAA,GAAsBuI,EACjC,EACIoB,SAAKC,GACLA,GAAU/J,EAAAA,EAAAA,GAAsB+J,GAChCrB,EAAcqB,EACG,OAAb1B,GAAsB/B,GAA6B,IAAVoB,EAIzCY,EAAYhC,EAAgBZ,MAAQqE,EAAUrC,EAH9CW,EAAW0B,CAKnB,EACIrM,eACA,IAAMA,EAA4C,OAAjCoI,EAAUjH,mBACrBgH,EAAsBC,GACtBA,EAAUjH,mBAChB,OAAOsB,EAAAA,EAAAA,GAAsBzC,EACjC,EACIgK,YACA,OAAOA,CACX,EACIA,UAAMsC,GACFA,IAAatC,GAAUpB,IAE3BoB,EAAQsC,EACRL,GAASG,MAAO3J,EAAAA,EAAAA,GAAsBuI,GAC1C,EACIxK,YACA,OAAOkK,CACX,EACAsB,KAAAA,GACAO,MAAO,WACH7B,EAAY,SACZC,EAAWK,CACf,EACAlD,KAAM,WACFmC,GAAa,EACK,SAAdS,IAEJA,EAAY,OACZb,GAAUA,IACVkC,IACJ,EACAA,OAAQ,WACe,OAAflB,GACAI,EAAKJ,GACTkB,GACJ,EACAS,SAAU,WACN9B,EAAY,UAChB,EACA+B,OAAQ,SAACrB,GAEL,OADAR,EAAY,EACLK,EAAKG,EAChB,GAEJ,OAAOa,EACX,C,kICpSMtN,EAAS,SAACI,GAAC,OAAK,EAAIjB,KAAKyH,IAAIzH,KAAK4O,KAAK3N,GAAG,EAC1CF,GAAUP,EAAAA,EAAAA,GAAcK,GACxBC,GAAYJ,EAAAA,EAAAA,GAAaK,E,wDCH/B,IAAML,EAAe,SAACsB,GAAM,OAAK,SAACf,GAAC,OAAKA,GAAK,GAAMe,EAAO,EAAIf,GAAK,GAAK,EAAIe,EAAO,GAAK,EAAIf,KAAO,CAAC,E,uDCApG,IAAMT,EAAgB,SAACwB,GAAM,OAAK,SAACf,GAAC,OAAK,EAAIe,EAAO,EAAIf,EAAE,E,+ECI1D,IAAMuD,EAAwB,SAACqK,GAAO,OAAe,IAAVA,CAAc,EACnDlK,EAAwB,SAACmK,GAAY,OAAKA,EAAe,GAAI,C","sources":["../node_modules/framer-motion/dist/es/easing/cubic-bezier.mjs","../node_modules/framer-motion/dist/es/easing/ease.mjs","../node_modules/framer-motion/dist/es/easing/back.mjs","../node_modules/framer-motion/dist/es/easing/utils/map.mjs","../node_modules/framer-motion/dist/es/easing/anticipate.mjs","../node_modules/framer-motion/dist/es/animation/generators/keyframes.mjs","../node_modules/framer-motion/dist/es/easing/utils/is-easing-array.mjs","../node_modules/framer-motion/dist/es/utils/offsets/time.mjs","../node_modules/framer-motion/dist/es/animation/generators/utils/velocity.mjs","../node_modules/framer-motion/dist/es/animation/generators/spring/find.mjs","../node_modules/framer-motion/dist/es/animation/generators/spring/index.mjs","../node_modules/framer-motion/dist/es/animation/generators/inertia.mjs","../node_modules/framer-motion/dist/es/animation/animators/js/driver-frameloop.mjs","../node_modules/framer-motion/dist/es/animation/generators/utils/calc-duration.mjs","../node_modules/framer-motion/dist/es/animation/animators/js/index.mjs","../node_modules/framer-motion/dist/es/easing/circ.mjs","../node_modules/framer-motion/dist/es/easing/modifiers/mirror.mjs","../node_modules/framer-motion/dist/es/easing/modifiers/reverse.mjs","../node_modules/framer-motion/dist/es/utils/time-conversion.mjs"],"sourcesContent":["import { noop } from '../utils/noop.mjs';\n\n/*\n  Bezier function generator\n  This has been modified from Gaëtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) *\n    t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return noop;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexport { cubicBezier };\n","import { cubicBezier } from './cubic-bezier.mjs';\n\nconst easeIn = cubicBezier(0.42, 0, 1, 1);\nconst easeOut = cubicBezier(0, 0, 0.58, 1);\nconst easeInOut = cubicBezier(0.42, 0, 0.58, 1);\n\nexport { easeIn, easeInOut, easeOut };\n","import { cubicBezier } from './cubic-bezier.mjs';\nimport { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);\nconst backIn = reverseEasing(backOut);\nconst backInOut = mirrorEasing(backIn);\n\nexport { backIn, backInOut, backOut };\n","import { invariant } from '../../utils/errors.mjs';\nimport { cubicBezier } from '../cubic-bezier.mjs';\nimport { noop } from '../../utils/noop.mjs';\nimport { easeIn, easeInOut, easeOut } from '../ease.mjs';\nimport { circIn, circInOut, circOut } from '../circ.mjs';\nimport { backIn, backInOut, backOut } from '../back.mjs';\nimport { anticipate } from '../anticipate.mjs';\n\nconst easingLookup = {\n    linear: noop,\n    easeIn,\n    easeInOut,\n    easeOut,\n    circIn,\n    circInOut,\n    circOut,\n    backIn,\n    backInOut,\n    backOut,\n    anticipate,\n};\nconst easingDefinitionToFunction = (definition) => {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);\n        const [x1, y1, x2, y2] = definition;\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === \"string\") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);\n        return easingLookup[definition];\n    }\n    return definition;\n};\n\nexport { easingDefinitionToFunction };\n","import { backIn } from './back.mjs';\n\nconst anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n\nexport { anticipate };\n","import { easeInOut } from '../../easing/ease.mjs';\nimport { isEasingArray } from '../../easing/utils/is-easing-array.mjs';\nimport { easingDefinitionToFunction } from '../../easing/utils/map.mjs';\nimport { interpolate } from '../../utils/interpolate.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { convertOffsetToTimes } from '../../utils/offsets/time.mjs';\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction keyframes({ duration = 300, keyframes: keyframeValues, times, ease = \"easeInOut\", }) {\n    /**\n     * Easing functions can be externally defined as strings. Here we convert them\n     * into actual functions.\n     */\n    const easingFunctions = isEasingArray(ease)\n        ? ease.map(easingDefinitionToFunction)\n        : easingDefinitionToFunction(ease);\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = {\n        done: false,\n        value: keyframeValues[0],\n    };\n    /**\n     * Create a times array based on the provided 0-1 offsets\n     */\n    const absoluteTimes = convertOffsetToTimes(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    times && times.length === keyframeValues.length\n        ? times\n        : defaultOffset(keyframeValues), duration);\n    const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {\n        ease: Array.isArray(easingFunctions)\n            ? easingFunctions\n            : defaultEasing(keyframeValues, easingFunctions),\n    });\n    return {\n        calculatedDuration: duration,\n        next: (t) => {\n            state.value = mapTimeToKeyframe(t);\n            state.done = t >= duration;\n            return state;\n        },\n    };\n}\n\nexport { defaultEasing, keyframes };\n","const isEasingArray = (ease) => {\n    return Array.isArray(ease) && typeof ease[0] !== \"number\";\n};\n\nexport { isEasingArray };\n","function convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\n\nexport { convertOffsetToTimes };\n","import { velocityPerSecond } from '../../../utils/velocity-per-second.mjs';\n\nconst velocitySampleDuration = 5; // ms\nfunction calcGeneratorVelocity(resolveValue, t, current) {\n    const prevT = Math.max(t - velocitySampleDuration, 0);\n    return velocityPerSecond(current - resolveValue(prevT), t - prevT);\n}\n\nexport { calcGeneratorVelocity };\n","import { warning } from '../../../utils/errors.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { secondsToMilliseconds, millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= secondsToMilliseconds(maxDuration), \"Spring duration must be 10 seconds or less\");\n    let dampingRatio = 1 - bounce;\n    /**\n     * Restrict dampingRatio and duration to within acceptable ranges.\n     */\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, millisecondsToSeconds(duration));\n    if (dampingRatio < 1) {\n        /**\n         * Underdamped spring\n         */\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        /**\n         * Critically-damped spring\n         */\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = secondsToMilliseconds(duration);\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };\n","import { millisecondsToSeconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorVelocity } from '../utils/velocity.mjs';\nimport { findSpring, calcAngularFreq } from './find.mjs';\n\nconst durationKeys = [\"duration\", \"bounce\"];\nconst physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = {\n        velocity: 0.0,\n        stiffness: 100,\n        damping: 10,\n        mass: 1.0,\n        isResolvedFromDuration: false,\n        ...options,\n    };\n    // stiffness/damping/mass overrides duration/bounce\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = {\n            ...springOptions,\n            ...derived,\n            velocity: 0.0,\n            mass: 1.0,\n        };\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring({ keyframes, restDelta, restSpeed, ...options }) {\n    const origin = keyframes[0];\n    const target = keyframes[keyframes.length - 1];\n    /**\n     * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator\n     * to reduce GC during animation.\n     */\n    const state = { done: false, value: origin };\n    const { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    const initialVelocity = velocity ? -millisecondsToSeconds(velocity) : 0.0;\n    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n    const initialDelta = target - origin;\n    const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));\n    /**\n     * If we're working on a granular scale, use smaller defaults for determining\n     * when the spring is finished.\n     *\n     * These defaults have been selected emprically based on what strikes a good\n     * ratio between feeling good and finishing as soon as changes are imperceptible.\n     */\n    const isGranularScale = Math.abs(initialDelta) < 5;\n    restSpeed || (restSpeed = isGranularScale ? 0.01 : 2);\n    restDelta || (restDelta = isGranularScale ? 0.005 : 0.5);\n    let resolveSpring;\n    if (dampingRatio < 1) {\n        const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n        // Underdamped spring\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            return (target -\n                envelope *\n                    (((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) /\n                        angularFreq) *\n                        Math.sin(angularFreq * t) +\n                        initialDelta * Math.cos(angularFreq * t)));\n        };\n    }\n    else if (dampingRatio === 1) {\n        // Critically damped spring\n        resolveSpring = (t) => target -\n            Math.exp(-undampedAngularFreq * t) *\n                (initialDelta +\n                    (initialVelocity + undampedAngularFreq * initialDelta) * t);\n    }\n    else {\n        // Overdamped spring\n        const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n        resolveSpring = (t) => {\n            const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n            // When performing sinh or cosh values can hit Infinity so we cap them here\n            const freqForT = Math.min(dampedAngularFreq * t, 300);\n            return (target -\n                (envelope *\n                    ((initialVelocity +\n                        dampingRatio * undampedAngularFreq * initialDelta) *\n                        Math.sinh(freqForT) +\n                        dampedAngularFreq *\n                            initialDelta *\n                            Math.cosh(freqForT))) /\n                    dampedAngularFreq);\n        };\n    }\n    return {\n        calculatedDuration: isResolvedFromDuration ? duration || null : null,\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                let currentVelocity = initialVelocity;\n                if (t !== 0) {\n                    /**\n                     * We only need to calculate velocity for under-damped springs\n                     * as over- and critically-damped springs can't overshoot, so\n                     * checking only for displacement is enough.\n                     */\n                    if (dampingRatio < 1) {\n                        currentVelocity = calcGeneratorVelocity(resolveSpring, t, current);\n                    }\n                    else {\n                        currentVelocity = 0;\n                    }\n                }\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? target : current;\n            return state;\n        },\n    };\n}\n\nexport { spring };\n","import { spring } from './spring/index.mjs';\nimport { calcGeneratorVelocity } from './utils/velocity.mjs';\n\nfunction inertia({ keyframes, velocity = 0.0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min, max, restDelta = 0.5, restSpeed, }) {\n    const origin = keyframes[0];\n    const state = {\n        done: false,\n        value: origin,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity;\n    const ideal = origin + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - origin;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDelta;\n        state.value = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring$1;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.value))\n            return;\n        timeReachedBoundary = t;\n        spring$1 = spring({\n            keyframes: [state.value, nearestBoundary(state.value)],\n            velocity: calcGeneratorVelocity(calcLatest, t, state.value),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDelta,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return {\n        calculatedDuration: null,\n        next: (t) => {\n            /**\n             * We need to resolve the friction to figure out if we need a\n             * spring but we don't want to do this twice per frame. So here\n             * we flag if we updated for this frame and later if we did\n             * we can skip doing it again.\n             */\n            let hasUpdatedFrame = false;\n            if (!spring$1 && timeReachedBoundary === undefined) {\n                hasUpdatedFrame = true;\n                applyFriction(t);\n                checkCatchBoundary(t);\n            }\n            /**\n             * If we have a spring and the provided t is beyond the moment the friction\n             * animation crossed the min/max boundary, use the spring.\n             */\n            if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n                return spring$1.next(t - timeReachedBoundary);\n            }\n            else {\n                !hasUpdatedFrame && applyFriction(t);\n                return state;\n            }\n        },\n    };\n}\n\nexport { inertia };\n","import { frame, cancelFrame } from '../../../frameloop/index.mjs';\nimport { frameData } from '../../../frameloop/data.mjs';\n\nconst frameloopDriver = (update) => {\n    const passTimestamp = ({ timestamp }) => update(timestamp);\n    return {\n        start: () => frame.update(passTimestamp, true),\n        stop: () => cancelFrame(passTimestamp),\n        /**\n         * If we're processing this frame we can use the\n         * framelocked timestamp to keep things in sync.\n         */\n        now: () => frameData.isProcessing ? frameData.timestamp : performance.now(),\n    };\n};\n\nexport { frameloopDriver };\n","/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxGeneratorDuration = 20000;\nfunction calcGeneratorDuration(generator) {\n    let duration = 0;\n    const timeStep = 50;\n    let state = generator.next(duration);\n    while (!state.done && duration < maxGeneratorDuration) {\n        duration += timeStep;\n        state = generator.next(duration);\n    }\n    return duration >= maxGeneratorDuration ? Infinity : duration;\n}\n\nexport { calcGeneratorDuration, maxGeneratorDuration };\n","import { keyframes } from '../../generators/keyframes.mjs';\nimport { spring } from '../../generators/spring/index.mjs';\nimport { inertia } from '../../generators/inertia.mjs';\nimport { frameloopDriver } from './driver-frameloop.mjs';\nimport { interpolate } from '../../../utils/interpolate.mjs';\nimport { clamp } from '../../../utils/clamp.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../../utils/time-conversion.mjs';\nimport { calcGeneratorDuration } from '../../generators/utils/calc-duration.mjs';\n\nconst types = {\n    decay: inertia,\n    inertia,\n    tween: keyframes,\n    keyframes: keyframes,\n    spring,\n};\n/**\n * Animate a single value on the main thread.\n *\n * This function is written, where functionality overlaps,\n * to be largely spec-compliant with WAAPI to allow fungibility\n * between the two.\n */\nfunction animateValue({ autoplay = true, delay = 0, driver = frameloopDriver, keyframes: keyframes$1, type = \"keyframes\", repeat = 0, repeatDelay = 0, repeatType = \"loop\", onPlay, onStop, onComplete, onUpdate, ...options }) {\n    let speed = 1;\n    let hasStopped = false;\n    let resolveFinishedPromise;\n    let currentFinishedPromise;\n    /**\n     * Create a new finished Promise every time we enter the\n     * finished state and resolve the old Promise. This is\n     * WAAPI-compatible behaviour.\n     */\n    const updateFinishedPromise = () => {\n        resolveFinishedPromise && resolveFinishedPromise();\n        currentFinishedPromise = new Promise((resolve) => {\n            resolveFinishedPromise = resolve;\n        });\n    };\n    // Create the first finished promise\n    updateFinishedPromise();\n    let animationDriver;\n    const generatorFactory = types[type] || keyframes;\n    /**\n     * If this isn't the keyframes generator and we've been provided\n     * strings as keyframes, we need to interpolate these.\n     * TODO: Support velocity for units and complex value types/\n     */\n    let mapNumbersToKeyframes;\n    if (generatorFactory !== keyframes &&\n        typeof keyframes$1[0] !== \"number\") {\n        mapNumbersToKeyframes = interpolate([0, 100], keyframes$1, {\n            clamp: false,\n        });\n        keyframes$1 = [0, 100];\n    }\n    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });\n    let mirroredGenerator;\n    if (repeatType === \"mirror\") {\n        mirroredGenerator = generatorFactory({\n            ...options,\n            keyframes: [...keyframes$1].reverse(),\n            velocity: -(options.velocity || 0),\n        });\n    }\n    let playState = \"idle\";\n    let holdTime = null;\n    let startTime = null;\n    let cancelTime = null;\n    /**\n     * If duration is undefined and we have repeat options,\n     * we need to calculate a duration from the generator.\n     *\n     * We set it to the generator itself to cache the duration.\n     * Any timeline resolver will need to have already precalculated\n     * the duration by this step.\n     */\n    if (generator.calculatedDuration === null && repeat) {\n        generator.calculatedDuration = calcGeneratorDuration(generator);\n    }\n    const { calculatedDuration } = generator;\n    let resolvedDuration = Infinity;\n    let totalDuration = Infinity;\n    if (calculatedDuration !== null) {\n        resolvedDuration = calculatedDuration + repeatDelay;\n        totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;\n    }\n    let currentTime = 0;\n    const tick = (timestamp) => {\n        if (startTime === null)\n            return;\n        /**\n         * requestAnimationFrame timestamps can come through as lower than\n         * the startTime as set by performance.now(). Here we prevent this,\n         * though in the future it could be possible to make setting startTime\n         * a pending operation that gets resolved here.\n         */\n        if (speed > 0)\n            startTime = Math.min(startTime, timestamp);\n        if (holdTime !== null) {\n            currentTime = holdTime;\n        }\n        else {\n            currentTime = (timestamp - startTime) * speed;\n        }\n        // Rebase on delay\n        const timeWithoutDelay = currentTime - delay;\n        const isInDelayPhase = timeWithoutDelay < 0;\n        currentTime = Math.max(timeWithoutDelay, 0);\n        /**\n         * If this animation has finished, set the current time\n         * to the total duration.\n         */\n        if (playState === \"finished\" && holdTime === null) {\n            currentTime = totalDuration;\n        }\n        let elapsed = currentTime;\n        let frameGenerator = generator;\n        if (repeat) {\n            /**\n             * Get the current progress (0-1) of the animation. If t is >\n             * than duration we'll get values like 2.5 (midway through the\n             * third iteration)\n             */\n            const progress = currentTime / resolvedDuration;\n            /**\n             * Get the current iteration (0 indexed). For instance the floor of\n             * 2.5 is 2.\n             */\n            let currentIteration = Math.floor(progress);\n            /**\n             * Get the current progress of the iteration by taking the remainder\n             * so 2.5 is 0.5 through iteration 2\n             */\n            let iterationProgress = progress % 1.0;\n            /**\n             * If iteration progress is 1 we count that as the end\n             * of the previous iteration.\n             */\n            if (!iterationProgress && progress >= 1) {\n                iterationProgress = 1;\n            }\n            iterationProgress === 1 && currentIteration--;\n            currentIteration = Math.min(currentIteration, repeat + 1);\n            /**\n             * Reverse progress if we're not running in \"normal\" direction\n             */\n            const iterationIsOdd = Boolean(currentIteration % 2);\n            if (iterationIsOdd) {\n                if (repeatType === \"reverse\") {\n                    iterationProgress = 1 - iterationProgress;\n                    if (repeatDelay) {\n                        iterationProgress -= repeatDelay / resolvedDuration;\n                    }\n                }\n                else if (repeatType === \"mirror\") {\n                    frameGenerator = mirroredGenerator;\n                }\n            }\n            let p = clamp(0, 1, iterationProgress);\n            if (currentTime > totalDuration) {\n                p = repeatType === \"reverse\" && iterationIsOdd ? 1 : 0;\n            }\n            elapsed = p * resolvedDuration;\n        }\n        /**\n         * If we're in negative time, set state as the initial keyframe.\n         * This prevents delay: x, duration: 0 animations from finishing\n         * instantly.\n         */\n        const state = isInDelayPhase\n            ? { done: false, value: keyframes$1[0] }\n            : frameGenerator.next(elapsed);\n        if (mapNumbersToKeyframes) {\n            state.value = mapNumbersToKeyframes(state.value);\n        }\n        let { done } = state;\n        if (!isInDelayPhase && calculatedDuration !== null) {\n            done = currentTime >= totalDuration;\n        }\n        const isAnimationFinished = holdTime === null &&\n            (playState === \"finished\" ||\n                (playState === \"running\" && done) ||\n                (speed < 0 && currentTime <= 0));\n        if (onUpdate) {\n            onUpdate(state.value);\n        }\n        if (isAnimationFinished) {\n            finish();\n        }\n        return state;\n    };\n    const stopAnimationDriver = () => {\n        animationDriver && animationDriver.stop();\n        animationDriver = undefined;\n    };\n    const cancel = () => {\n        playState = \"idle\";\n        stopAnimationDriver();\n        updateFinishedPromise();\n        startTime = cancelTime = null;\n    };\n    const finish = () => {\n        playState = \"finished\";\n        onComplete && onComplete();\n        stopAnimationDriver();\n        updateFinishedPromise();\n    };\n    const play = () => {\n        if (hasStopped)\n            return;\n        if (!animationDriver)\n            animationDriver = driver(tick);\n        const now = animationDriver.now();\n        onPlay && onPlay();\n        if (holdTime !== null) {\n            startTime = now - holdTime;\n        }\n        else if (!startTime || playState === \"finished\") {\n            startTime = now;\n        }\n        cancelTime = startTime;\n        holdTime = null;\n        /**\n         * Set playState to running only after we've used it in\n         * the previous logic.\n         */\n        playState = \"running\";\n        animationDriver.start();\n    };\n    if (autoplay) {\n        play();\n    }\n    const controls = {\n        then(resolve, reject) {\n            return currentFinishedPromise.then(resolve, reject);\n        },\n        get time() {\n            return millisecondsToSeconds(currentTime);\n        },\n        set time(newTime) {\n            newTime = secondsToMilliseconds(newTime);\n            currentTime = newTime;\n            if (holdTime !== null || !animationDriver || speed === 0) {\n                holdTime = newTime;\n            }\n            else {\n                startTime = animationDriver.now() - newTime / speed;\n            }\n        },\n        get duration() {\n            const duration = generator.calculatedDuration === null\n                ? calcGeneratorDuration(generator)\n                : generator.calculatedDuration;\n            return millisecondsToSeconds(duration);\n        },\n        get speed() {\n            return speed;\n        },\n        set speed(newSpeed) {\n            if (newSpeed === speed || !animationDriver)\n                return;\n            speed = newSpeed;\n            controls.time = millisecondsToSeconds(currentTime);\n        },\n        get state() {\n            return playState;\n        },\n        play,\n        pause: () => {\n            playState = \"paused\";\n            holdTime = currentTime;\n        },\n        stop: () => {\n            hasStopped = true;\n            if (playState === \"idle\")\n                return;\n            playState = \"idle\";\n            onStop && onStop();\n            cancel();\n        },\n        cancel: () => {\n            if (cancelTime !== null)\n                tick(cancelTime);\n            cancel();\n        },\n        complete: () => {\n            playState = \"finished\";\n        },\n        sample: (elapsed) => {\n            startTime = 0;\n            return tick(elapsed);\n        },\n    };\n    return controls;\n}\n\nexport { animateValue };\n","import { mirrorEasing } from './modifiers/mirror.mjs';\nimport { reverseEasing } from './modifiers/reverse.mjs';\n\nconst circIn = (p) => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\n\nexport { circIn, circInOut, circOut };\n","// Accepts an easing function and returns a new one that outputs mirrored values for\n// the second half of the animation. Turns easeIn into easeInOut.\nconst mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n\nexport { mirrorEasing };\n","// Accepts an easing function and returns a new one that outputs reversed values.\n// Turns easeIn into easeOut.\nconst reverseEasing = (easing) => (p) => 1 - easing(1 - p);\n\nexport { reverseEasing };\n","/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nconst secondsToMilliseconds = (seconds) => seconds * 1000;\nconst millisecondsToSeconds = (milliseconds) => milliseconds / 1000;\n\nexport { millisecondsToSeconds, secondsToMilliseconds };\n"],"names":["calcBezier","t","a1","a2","cubicBezier","mX1","mY1","mX2","mY2","noop","getTForX","aX","x","lowerBound","upperBound","currentX","currentT","i","Math","abs","binarySubdivide","easeIn","easeOut","easeInOut","backOut","backIn","reverseEasing","backInOut","mirrorEasing","easingLookup","linear","circIn","circInOut","circOut","anticipate","p","pow","easingDefinitionToFunction","definition","Array","isArray","invariant","length","_definition","_slicedToArray","undefined","concat","keyframes","_ref","values","easing","_ref$duration","duration","keyframeValues","times","_ref$ease","ease","easingFunctions","isEasingArray","map","state","done","value","absoluteTimes","offset","o","convertOffsetToTimes","defaultOffset","mapTimeToKeyframe","interpolate","splice","calculatedDuration","next","calcGeneratorVelocity","resolveValue","current","prevT","max","velocityPerSecond","safeMin","findSpring","envelope","derivative","_ref$bounce","bounce","_ref$velocity","velocity","_ref$mass","mass","warning","secondsToMilliseconds","dampingRatio","clamp","millisecondsToSeconds","undampedFreq","exponentialDecay","delta","a","b","calcAngularFreq","c","exp","d","e","f","g","initialGuess","result","approximateRoot","isNaN","stiffness","damping","sqrt","durationKeys","physicsKeys","isSpringType","options","keys","some","key","spring","resolveSpring","restDelta","restSpeed","_objectWithoutProperties","_excluded","origin","target","_getSpringOptions","springOptions","_objectSpread","isResolvedFromDuration","derived","getSpringOptions","initialVelocity","initialDelta","undampedAngularFreq","isGranularScale","angularFreq","sin","cos","dampedAngularFreq","freqForT","min","sinh","cosh","currentVelocity","isBelowVelocityThreshold","isBelowDisplacementThreshold","inertia","_ref$power","power","_ref$timeConstant","timeConstant","_ref$bounceDamping","bounceDamping","_ref$bounceStiffness","bounceStiffness","modifyTarget","_ref$restDelta","nearestBoundary","v","amplitude","ideal","timeReachedBoundary","spring$1","calcDelta","calcLatest","applyFriction","latest","checkCatchBoundary","hasUpdatedFrame","frameloopDriver","update","passTimestamp","timestamp","start","frame","stop","cancelFrame","now","frameData","performance","calcGeneratorDuration","generator","Infinity","types","decay","tween","animateValue","resolveFinishedPromise","currentFinishedPromise","animationDriver","_ref$autoplay","autoplay","_ref$delay","delay","_ref$driver","driver","keyframes$1","_ref$type","type","_ref$repeat","repeat","_ref$repeatDelay","repeatDelay","_ref$repeatType","repeatType","onPlay","onStop","onComplete","onUpdate","speed","hasStopped","updateFinishedPromise","Promise","resolve","mapNumbersToKeyframes","generatorFactory","mirroredGenerator","_toConsumableArray","reverse","playState","holdTime","startTime","cancelTime","resolvedDuration","totalDuration","currentTime","tick","timeWithoutDelay","isInDelayPhase","elapsed","frameGenerator","progress","currentIteration","floor","iterationProgress","iterationIsOdd","Boolean","isAnimationFinished","finish","stopAnimationDriver","cancel","play","controls","then","reject","time","newTime","newSpeed","pause","complete","sample","acos","seconds","milliseconds"],"sourceRoot":""}